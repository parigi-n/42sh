builtin/builtin.c:      my_show_list(var->env);
builtin/builtin.c:    end = erase_list(&var->env, tab[1]);
builtin/builtin.c:    end = add_list_stock(&var->env, tab[1], tab[2]);
builtin/builtin.c:  var->status = end;
builtin/exit.c:  free_list(&var->env);
builtin/exit.c:  free_list(&var->alias);
builtin/exit.c:  free_list_pars(&var->buffer);
builtin/exit.c:  free(var->buff);
builtin/cd.c:  if ((env = my_getstock(&var->env, "HOME")) != NULL)
builtin/cd.c:      if ((env = my_getstock(&var->env, "HOME")) != NULL)
builtin/cd.c:    env = my_getstock(&var->env, "OLDPWD"));
builtin/alias.c:    end = add_list_stock(&var->alias, tab[1], tab[2]);
builtin/alias.c:      my_show_list(var->alias);
get_cmd/unraw_get_str.c:  var->term.i = 0;
get_cmd/unraw_get_str.c:  var->buff = get_next_line(0);
get_cmd/unraw_get_str.c:  if (var->buff == NULL)
get_cmd/raw_get_str.c:      if ((len = my_strlen (var->buff)) > 0)
get_cmd/raw_get_str.c:	  eff_line(var->buff);
get_cmd/raw_get_str.c:	  var->buff[len - 1] = '\0';
get_cmd/raw_get_str.c:    var->buff = re_alloc(var->buff, c);
get_cmd/raw_get_str.c:  if (raw_mode(&var->env) == ERROR)
get_cmd/raw_get_str.c:  if ((var->buff = malloc(1)) == NULL)
get_cmd/raw_get_str.c:  var->buff[0] = '\0';
get_cmd/raw_get_str.c:  var->term.i = 0;
get_cmd/raw_get_str.c:	  var->term.i = 0;
get_cmd/find_hist.c:  if (var->buff[0] == '!')
get_cmd/find_hist.c:    str = find_hist(&var->term.hist, var->buff);
get_cmd/find_hist.c:      free(var->buff);
get_cmd/find_hist.c:      if ((var->buff = my_strcpy(str)) == NULL)
get_cmd/init.c:  if ((my_getstock(&var->env, "TERM") == NULL)
get_cmd/init.c:      && var->term.curse == 1)
get_cmd/key.c:  /*if (var->term.hist < onche)*/
get_cmd/key.c:    var->term.hist = var->term.hist - 1;
get_cmd/key.c:  if (var->term.hist > 0)
get_cmd/key.c:    var->term.hist = var->term.hist - 1;
get_cmd/key.c:  if (var->term.i < my_strlen (var->buff))
get_cmd/key.c:    var->term.i = var->term.i + 1;
get_cmd/key.c:  if (var->term.i > 0)
get_cmd/key.c:    var->term.i = var->term.i - 1;
get_cmd/alias.c:      if ((alias = my_getstock(&var->alias, tab[i])) != NULL)
get_cmd/alias.c:	  if ((var->buff = (alias_cat(var->buff,
get_cmd/alias.c:      if ((tab = my_word_to_tab(var->buff, " ")) == NULL)
get_cmd/fct_get_str.c:  i = my_strlen (var->buff);
get_cmd/fct_get_str.c:  while (i > 0 && var->buff[i] != '\n')
get_cmd/fct_get_str.c:  if (var->buff[i] == '\n')
get_cmd/fct_get_str.c:  while (var->buff[i] != '\0')
get_cmd/fct_get_str.c:    write(1, &var->buff[i++], 1);
main.c:  var->env = NULL;
main.c:  var->alias = NULL;
main.c:  var->buffer = NULL;
main.c:  var->term.i = 0;
main.c:  var->term.pos = 0;
main.c:  var->term.lim_hist = 50;
main.c:  var->envp = envp;
main.c:  var->term.curse = 0;
main.c:    var->term.curse = 1;
main.c:  if (get_env(&var->env, var->envp) == -1)
main.c:  my_prompt(var->term.prompt, &var->env);
42shrc/init.c:	  if (list_stock_rc(&var->alias, raw_line) == ERROR)
42shrc/init.c:  var->term.prompt = NULL;
42shrc/init.c:  if ((home = my_getstock(&var->env, "HOME")) != NULL)
42shrc/init.c:  if (var->term.prompt == NULL)
42shrc/init.c:    var->term.prompt = DEFAULT_PROMPT;
exe_command.c:  var->check = 0;
exe_command.c:  var->exe.tmp = NULL;
exe_command.c:  var->exe.envi = NULL;
exe_command.c:  if ((var->exe.envtab = do_tab_exec(&var->env)) == NULL)
exe_command.c:  if ((var->exe.envi = do_env(&var->env)) == NULL)
exe_command.c:  if ((var->exe.tmp = my_strcpy(tab[0])) == NULL)
exe_command.c:  if ((str = my_strcat(var->exe.tmp, "/")) == NULL)
exe_command.c:  if ((tab[0] = my_strcat(str, var->envi[i])) == NULL)
exe_command.c:      var->check = 1;
exe_command.c:      execve(tab[0], tab, var->envtab);
exe_command.c:      var->check = 1;
exe_command.c:      execve(tab[0], tab, var->envtab);
exe_command.c:  while (var->envi[i] != NULL)
len:exe_command.c:  var->check = 0;
len:exe_command.c:  var->new = NULL;
len:exe_command.c:  var->envi = NULL;
len:exe_command.c:  var->alias = NULL;
len:exe_command.c:  if ((var->envtab = do_tab_exec(&var->env)) == NULL)
len:exe_command.c:  if ((var->envi = do_env(&var->env)) == NULL)
len:exe_command.c:  if ((var->new = my_strcpy(tab[0])) == NULL)
len:exe_command.c:  if ((str = my_strcat(var->new, "/")) == NULL)
len:exe_command.c:  if ((tab[0] = my_strcat(str, var->envi[i])) == NULL)
len:exe_command.c:      var->check = 1;
len:exe_command.c:      execve(tab[0], tab, var->envtab);
len:exe_command.c:      var->check = 1;
len:exe_command.c:      execve(tab[0], tab, var->envtab);
len:exe_command.c:  while (var->envi[i] != NULL)
len:exe_solo.c:	wait(&var->status);
len:main.c:  var->env = NULL;
len:main.c:  var->alias = NULL;
len:main.c:  var->buffer = NULL;
len:main.c:  var->term.i = 0;
len:main.c:  var->envp = envp;
len:main.c:  if (get_env(&var->env, var->envp) == -1)
len:mysh.c:  if (var->status == FAIL_STATUS)
len:mysh.c:  else if (var->status != 0)
len:mysh.c:  free_list_pars(&var->buffer);
len:mysh.c:      do_mysh(var, &var->buffer);
len:mysh.c:      free(var->buff);
exe_solo.c:	wait(&var->status);
pars/parseur.c:  var->buffer = NULL;
pars/parseur.c:  while (var->buff[i] != '\0')
pars/parseur.c:      len = parsing_len((char *)var->buff, i);
pars/parseur.c:      new = parsing_add(var->buff, &i, new);
pars/parseur.c:      if ((type = find_type(var->buff, &i)) < 1)
pars/parseur.c:      if ((my_put_in_list_pars(&var->buffer,
pars/parseur.c:  var->buffer = NULL;
pars/parseur.c:  if ((var->buff = epur_str(var->buff, 1)) == NULL)
pars/parseur.c:  if (var->buff[0] == '\0')
pars/parseur.c:  if ((var->buffer = reverse_list_pars(var->buffer)) == NULL)
pars/parseur.c:  prev_list_pars(&var->buffer);
pars/alias.c:      if ((alias = my_getstock(&var->alias, tab[i])) != NULL)
pars/alias.c:	  if ((var->buff = (alias_cat(var->buff,
pars/alias.c:      if ((var->buff = epur_str(var->buff, 1)) == NULL)
pars/alias.c:      if ((tab = my_word_to_tab(var->buff)) == NULL)
pars/alias.c:  if ((var->buff = epur_str(var->buff, 1)) == NULL)
mysh.c:  if (var->status == FAIL_STATUS)
mysh.c:  else if (var->status != 0)
mysh.c:  free_list_pars(&var->buffer);
mysh.c:  var->buffer = NULL;
mysh.c:      my_printf("str: %s\n", var->buff);
mysh.c:      my_show_list_pars(var->buffer);
mysh.c:      do_mysh(var, &var->buffer);
mysh.c:      free(var->buff);
mysh.c:      my_prompt(var->term.prompt, &var->env);
prompt/prompt.c:	  var->term.prompt = my_strcpy(tab[3]);
